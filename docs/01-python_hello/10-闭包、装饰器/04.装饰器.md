# 装饰器

**学习目标**

* 能够知道定义装饰器的语法格式

---

### 1. 装饰器的定义

就是**给已有函数增加额外功能的函数，它本质上就是一个闭包函数**。

**装饰器的功能特点:**

1. 不修改已有函数的源代码
2. 不修改已有函数的调用方式
3. 给已有函数增加额外的功能


### 2. 装饰器的示例代码

```py
# 添加一个登录验证的功能
def check(fn):
    def inner():
        print("请先登录....")
        fn()
    return inner


def comment():
    print("发表评论")

# 使用装饰器来装饰函数
comment = check(comment)
comment()

# 装饰器的基本雏形
# def decorator(fn): # fn:目标函数.
#     def inner():
#         '''执行函数之前'''
#         fn() # 执行被装饰的函数
#         '''执行函数之后'''
#     return inner

```

**代码说明:**

* 闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。
* 写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。


**执行结果:**

```py
请先登录....
发表评论
```

### 3. 装饰器的语法糖写法

如果有多个函数都需要添加登录验证的功能，每次都需要编写func = check(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。

Python给提供了一个装饰函数更加简单的写法，那就是语法糖，语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰

```py
# 添加一个登录验证的功能
def check(fn):
    print("装饰器函数执行了")
    def inner():
        print("请先登录....")
        fn()
    return inner

# 使用语法糖方式来装饰函数
@check
def comment():
    print("发表评论")


comment()
```

**说明:**

* @check 等价于 comment = check(comment)
* 装饰器的执行时间是加载模块时立即执行。



**执行结果:**

```py
请先登录....
发表评论
```

### 4. 小结

* 装饰器本质上就是一个闭包函数，它可以对已有函数进行额外的功能扩展。
* 装饰器的语法格式:

  ```py
  # 装饰器
  # def decorator(fn): # fn:被装饰的目标函数.
  #     def inner():
  #         '''执行函数之前'''
  #         fn() # 执行被装饰的目标函数
  #         '''执行函数之后'''
  #     return inner
  ``` 
* 装饰器的语法糖用法: @装饰器名称，同样可以完成对已有函数的装饰操作。







